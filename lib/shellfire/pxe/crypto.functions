# This file is part of pxe. It is subject to the licence terms in the COPYRIGHT file found in the top-level directory of this distribution and at https://raw.githubusercontent.com/lemonrock/pxe/master/COPYRIGHT. No part of pxe, including this file, may be copied, modified, propagated, or distributed except according to the terms contained in the COPYRIGHT file.
# Copyright Â© 2014-2015 The developers of pxe. See the COPYRIGHT file in the top-level directory of this distribution and at https://raw.githubusercontent.com/lemonrock/pxe/master/COPYRIGHT.


pxe_crypto_newCertificateAuthority()
{
	_pxe_crypto_generateNewPrivateRootCertificate
	_pxe_crypto_generateNewServerAuthenticationCertificate
	_pxe_crypto_generateNewCodeSigningCertificate
}

# TODO: These will eventually need to be embedded into stunnel
# TODO: Probably ought to store these in a client folder?
pxe_crypto_generateNewClientAuthenticationCertificate()
{
	local clientId="$1"
	_pxe_crypto_openssl_new_request "$clientId".client
    _pxe_crypto_openssl_ca "$clientId".client
}

core_dependency_requires '*' openssl
_pxe_crypto_generateCertificateAuthorityCertificate()
{
	# TODO: Subject details so generation is automated
	openssl req -x509 -newkey rsa:4096 -out "$pxe_certificateAuthorityCertFilePath" -keyout "$pxe_certificateAuthorityKeyFilePath" -days 10000
}

# TODO: These will eventually need to be embedded into stunnel
# TODO: Probably ought to store these in a client folder?
_pxe_crypto_generateNewServerAuthenticationCertificate()
{
	_pxe_crypto_openssl_new_request server
    _pxe_crypto_openssl_ca server
}

_pxe_crypto_generateNewCodeSigningCertificate()
{
	_pxe_crypto_openssl_new_request "code-signing"
	_pxe_crypto_openssl_ca_sign "code-signing" -extensions codesigning
}

core_dependency_requires '*' openssl
pxe_crypto_signCode()
{
	local codeFilePath="$1"
	openssl cms -sign -binary -noattr -in "$codeFilePath" -signer "$pxe_certificatesFolderPath"/code-signing.crt -inkey "$pxe_certificatesFolderPath"/code-signing.key \
		-certfile "$pxe_certificateAuthorityCertFilePath" -outform DER -out "$codeFilePath".sig
}

core_dependency_requires '*' openssl
_pxe_crypto_openssl_new_request()
{
	local requestBaseName="$1"
    openssl req -newkey rsa:4096 -out "$pxe_certificatesFolderPath"/"$requestBaseName".req -keyout "$pxe_certificatesFolderPath"/"$requestBaseName".key
}

_pxe_crypto_openssl_ca_sign()
{
	local requestBaseName="$1"
	shift 1
	_pxe_crypto_openssl_ca -in "$pxe_certificatesFolderPath"/"$requestBaseName".req -out "$pxe_certificatesFolderPath"/"$requestBaseName".crt "$@"
}

core_dependency_requires '*' openssl
_pxe_crypto_openssl_ca_crossSign()
{
	local inCertificateFilePath="$1"
	local outCertificateFilePath="$2"
	_pxe_crypto_openssl_ca -extensions cross -notext -preserveDN -ss_cert "$inCertificateFilePath" -out "$outCertificateFilePath"
}

core_dependency_requires '*' openssl
_pxe_crypto_openssl_ca()
{
	pxe_certificateAuthorityFolderPath="$pxe_certificateAuthorityFolderPath" openssl ca -config "$pxe_openSslCertificateAuthorityCnfFilePath"
}

code signing
  openssl req -newkey rsa -keyout codesign.key -out codesign.req
  openssl ca -config ca.cnf -extensions codesigning -in codesign.req -out codesign.crt

You can now use this certificate to sign a binary that will then be trusted by iPXE. For example, to sign the binary vmlinuz:

 