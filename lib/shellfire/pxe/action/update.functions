# This file is part of pxe. It is subject to the licence terms in the COPYRIGHT file found in the top-level directory of this distribution and at https://raw.githubusercontent.com/lemonrock/pxe/master/COPYRIGHT. No part of pxe, including this file, may be copied, modified, propagated, or distributed except according to the terms contained in the COPYRIGHT file.
# Copyright Â© 2014-2015 The developers of pxe. See the COPYRIGHT file in the top-level directory of this distribution and at https://raw.githubusercontent.com/lemonrock/pxe/master/COPYRIGHT.


core_usesIn pxe openssl
core_dependency_requires '*' make git rm mv
core_dependency_requires '*' gcc ld perl ar
# Effectively, add or update client...
pxe_action_update_undionly()
{
	local clientId='any'
	
	pxe_alpine_installPackages alpine-sdk xz-dev

	# At this point in time, we can not serve different undionly.kpxe files without re-generating dnsmasq.conf
	# TODO: Get the vmlinuz image for this client if set up...
	# pxe_crypto_signCode "$pxe_httpdFolderPath"/boot/vmlinuz."$clientId"
	# pxe_crypto_generateNewClientAuthenticationCertificate "$clientId"

	local iPxeFolderPath="$_program_etcPath"/shellfire/pxe/iPXE
	local currentIPxeFolderPath="$iPxeFolderPath"/current
		
	pushd "$currentIPxeFolderPath"
		
		make clean 1>/dev/null 2>/dev/null || true
		git reset --hard --quiet
		git clean -d --force --quiet -x
		
		pushd src
		
			make bin/undionly.kpxe 1>/dev/null 2>/dev/null EMBED="$iPxeFolderPath"/embed.ipxe CERT="$pxe_certificateAuthorityCertFilePath","$pxe_certificatesFolderPath"/"$clientId".client.crt TRUST="$pxe_certificateAuthorityCertFilePath" PRIVKEY="$pxe_certificatesFolderPath"/"$clientId".client.key
		
		popd
		
		rm -rf "$pxe_ipxe_destinationFolderPath"/"$clientId".undionly.kpxe
		mv "$currentIPxeFolderPath"/src/bin/undionly.kpxe "$pxe_ipxe_destinationFolderPath"/"$clientId".undionly.kpxe
		
		make clean 1>/dev/null 2>/dev/null || true
		git reset --hard --quiet
		git clean -d --force --quiet -x
		
	popd
}

core_dependency_requires '*' rm curl dos2unix sed cp
pxe_action_update_malware_hosts()
{
	local hostsFolderPath="$_program_etcPath"/shellfire/pxe/dnsmasq/hosts/hosts.d
	local hostFileUrlsFilePath="$_program_etcPath"/shellfire/pxe/host-file-urls
	
	pushd "$hostsFolderPath"
		set +f
			local malwareFileName
			for malwareFileName in *.malware.hosts
			do
				set -f
				local noLongerDownloaded=true
				local originalName="${malwareFileName%.malware.hosts}"

				local name
				local url
				while read -r name url
				do
					if [ "$originalName" = "$name" ]; then
						noLongerDownloaded=false
						break
					fi
				done <"$hostFileUrlsFilePath"
			
				if $noLongerDownloaded; then
					rm -rf "$malwareFileName"
				fi
			done
		set -f
	popd
	
	local TMP_FILE
	local name
	local url
	while read -r name url
	do
		core_temporaryFiles_newFileToRemoveOnExit
		# Ignore curl errors; a provider may be temporarily offline
		core_message INFO "Downloading malware hosts list '$name' from '$url'"
		curl --fail --silent --location "$url" >"$TMP_FILE" || continue
		dos2unix "$TMP_FILE" 1>/dev/null 2>/dev/null
		sed -i 's/^127.0.0.1/0.0.0.0/g' "$TMP_FILE"
		sed -i '/ localhost$/d' "$TMP_FILE"
		sed -i '/ broadcasthost$/d' "$TMP_FILE"
		sed -i '/ local$/d' "$TMP_FILE"
		sed -i '/ localhost.localdomain$/d' "$TMP_FILE"
		sed -i '/^::1/d' "$TMP_FILE"
		cp -f "$TMP_FILE" "$hostsFolderPath"/"$name".malware.hosts
		# Even though we clean up tmp files at program termination, these files are potentially quite large for a temp space
		rm "$TMP_FILE"
	done <"$hostFileUrlsFilePath"
}